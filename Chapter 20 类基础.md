# Chapter 20 类基础

## 1. this指针

指向当前对象，是顶层const指针（class_t *const this = &current_object）  
成员函数必须通过this指针访问类内其他成员  
成员函数直接使用其他成员时其实是省略了this  
this也可看做是每一个成员函数的隐式参数  
成员函数返回this指针指向的对象时，返回类型必须是引用类型（左值），否则会变成原对象的拷贝

## 2. 常量成员函数

用法：在函数声明的括号后面加一个const标识符  
由于this指针本身不带底层const，故普通成员函数不能访问常量对象  
常量成员函数的this指针是const class_t *const类型  
也因此，常量成员函数不能修改其他成员  
const对象只能访问const成员函数  
常量成员函数返回this指针指向的对象时，返回类型若是引用类型，则会返回常量引用（const class_t&）  
const声明可作为函数重载的区分条件，非常量对象优先访问非const版本，常量对象优先访问const版本

## 3. 类的作用域

类本身是一个作用域，成员函数内部是嵌套的作用域  
类内部定义的函数是隐式的inline函数
编译器先编译成员声明，再编译成员函数体，故成员函数可以写在其他成员的前面  
可以定义非成员函数来实现类的某些接口，但一般把这些函数声明在和相关类的同一个头文件内

## 4. 构造函数

1. 构造函数不能声明为const，创建const对象时，先调用构造函数初始化，然后才被赋予const属性，故构造函数可以向const对象写值  
2. 编译器创建的默认构造函数（合成的默认构造函数）的规则是：
    - 若存在类内初始值，使用该初始值初始化成员（有些编译器不支持类内初始值）
    - 否则不初始化成员
3. 若在类内定义了非默认构造函数，则编译器不会再创建合成的默认构造函数，此时对象无法默认初始化
4. 合成的默认构造函数可能会初始化为未定义值
5. 若类内有无默认构造函数的类型的成员，则也无法生成合成的默认构造函数
6. 如果在3的情况下还是需要合成的默认构造函数，则可以使用 = default 来声明或定义
7. 构造函数也会根据是否在类内定义决定其是否是inline函数
8. 若编译器支持类内初始值，则无须修改该值时最好不要在构造函数中初始化该值
9. 构造函数初始值列表的使用举例

    ```C++
    class A
    {
    public:
        A();
        A(double, const char*);

    private:
        int m_a;
        double m_b;
        const char* m_c;
    };

    A::A() = default;

    A::A(double b, const char* c): m_a(0), m_b(b), m_c(c)
    {
        cout << "Constructor with initialize list has been called" << endl;
    };

    int main()
    {
        A a(3.14, "hello");
        return 0;
    }
    ```

## 5. 合成的默认拷贝操作

相当于对每个成员分别作赋值操作

## 6. 默认访问权限

class：private  
struct：public

## 7. 友元

在类内部定义或声明函数或类时加friend关键字，说明其不是成员函数或为其他类，但可以访问私有成员  
友元不是类的成员，故可以声明在任何地方  
友元声明仅声明了权限，未声明函数，故须在外部重新声明才能使用，通常把友元和类的声明放在同一个头文件中  
类内定义的友元函数也是隐式内联的  
其他类的私有成员函数不能设为友元  
友元类代表友元类的成员函数可以访问当前类的所有成员，包括私有成员  
友元关系不具有传递性，自己友元类的友元类不是自己的友元类  
需注意友元函数的外部声明导致的友元函数的作用域问题（有些编译器不存在这个问题）

```C++
struct A
{
    friend void fr_f() {}
    void X() {fr_f();} // 错误，fr_f还未声明
    void Y();
    void Z();
}

void A::Y(){fr_f()}; // 错误，fr_f还未声明
void fr_f();
void A::Z(){fr_f()}; // 正确
```

## 8. 类型成员

在public处使用using或typedef规定类型别名，则类外部可以使用这个别名，以实现封装  
须注意类型成员必须先定义后使用，故一般声明在类成员的最前面

## 9. 显式inline成员函数

可以在声明时说明，也可以在定义时说明，最好是只在类外定义，且只在定义时说明  
显式inline成员函数一般也定义在头文件中

## 10. 可变数据成员

数据成员声明前面加mutable关键字，用于说明其在const成员函数中也可以修改  
即便是const对象调用const成员函数也可以

## 11. 类内初始化注意事项

必须使用拷贝（等号）初始化或花括号初始化

## 12. 类的声明

```C++
class A;
```

这种只声明的类型A是不完全类型，只能声明指向这种类型的指针和引用、形参和返回类型，不能声明对象  
也因此，类内部可以定义指向其自身类型的引用和指针
