# Chapter 20 类基础

## 1. this指针

指向当前对象，是顶层const指针（class_t *const this = &current_object）  
成员函数必须通过this指针访问类内其他成员  
成员函数直接使用其他成员时其实是省略了this  
this也可看做是每一个成员函数的隐式参数  
成员函数返回this指针指向的对象时，返回类型必须是引用类型（左值），否则会变成原对象的拷贝

## 2. 常量成员函数

用法：在函数声明的括号后面加一个const标识符  
由于this指针本身不带底层const，故普通成员函数不能访问常量对象  
常量成员函数的this指针是const class_t *const类型  
也因此，常量成员函数不能修改其他成员  
const对象只能访问const成员函数  
常量成员函数返回this指针指向的对象时，返回类型若是引用类型，则会返回常量引用（const class_t&）  
const声明可作为函数重载的区分条件，非常量对象优先访问非const版本，常量对象优先访问const版本

## 3. 类的作用域

类本身是一个作用域，成员函数内部是嵌套的作用域  
类内部定义的函数是隐式的inline函数
编译器先编译成员声明，再编译成员函数体，故成员函数可以写在其他成员的前面  
可以定义非成员函数来实现类的某些接口，但一般把这些函数声明在和相关类的同一个头文件内

## 4. 合成的默认拷贝操作

相当于对每个成员分别作赋值操作

## 5. 默认访问权限

class：private  
struct：public

## 6. 友元

在类内部定义或声明函数或类时加friend关键字，说明其不是成员函数或为其他类，但可以访问私有成员  
友元不是类的成员，故可以声明在任何地方  
友元声明仅声明了权限，未声明函数，故须在外部重新声明才能使用，通常把友元和类的声明放在同一个头文件中  
类内定义的友元函数也是隐式内联的  
其他类的私有成员函数不能设为友元  
友元类代表友元类的成员函数可以访问当前类的所有成员，包括私有成员  
友元关系不具有传递性，自己友元类的友元类不是自己的友元类  
需注意友元函数的外部声明导致的友元函数的作用域问题（有些编译器不存在这个问题）

```C++
struct A
{
    friend void fr_f() {}
    void X() {fr_f();} // 错误，fr_f还未声明
    void Y();
    void Z();
}

void A::Y(){fr_f()}; // 错误，fr_f还未声明
void fr_f();
void A::Z(){fr_f()}; // 正确
```

## 7. 类型成员

在public处使用using或typedef规定类型别名，则类外部可以使用这个别名，以实现封装  
须注意类型成员必须先定义后使用，故一般声明在类成员的最前面

## 8. 显式inline成员函数

可以在声明时说明，也可以在定义时说明，最好是只在类外定义，且只在定义时说明  
显式inline成员函数一般也定义在头文件中

## 9. 可变数据成员

数据成员声明前面加mutable关键字，用于说明其在const成员函数中也可以修改  
即便是const对象调用const成员函数也可以

## 10. 类内初始化注意事项

必须使用拷贝（等号）初始化或花括号初始化

## 11. 类的声明

```C++
class A;
```

这种只声明的类型A是不完全类型，只能声明指向这种类型的指针和引用、形参和返回类型，不能声明对象  
也因此，类内部可以定义指向其自身类型的引用和指针

## 13. 名字查找

通常的名字查找过程是：

- 在名字所在块中的名字出现位置之前寻找声明
- 若未找到，继续寻找外层的作用域
- 若最终未找到，则报错

类的定义分两步：

- 编译成员声明
- 编译函数体

因此，成员函数中的名字查找方式较为不同：

- 在名字所在块中的名字出现位置之前寻找声明
- 若未找到，在类内继续查找，此时所有成员不分顺序都可以
- 若在类内未找到，则在外层作用域的成员函数定义之前的部分继续寻找
- 如果有成员使用过外部定义的类型名，则在类内不可以再重新定义

下面是一些例子：

```C++
typedef int integer;
double var;
class A
{
public:
    integer f() {return var;}
private:
    integer var;
};
// 编译器从发现f()的声明开始，先找integer的声明
// 首先在类内寻找，未发现声明
// 之后，在类外向前寻找发现声明
// 编译完类声明后，编译成员函数体，此时return语句中的var在类内寻找可以找到
// 故返回的var是类内成员而不是外部的double类型的var
```

```C++
typedef int integer;
class A
{
public:
    integer f() {return var;} // 此处左边的integer返回类型使用外层定义
private:
    typedef int integer; // 已经使用过外层integer，故此处定义错误
    integer var;
};
```

```C++
int var = 0;
class A
{
public:
    typedef int integer;
    void f(integer var)
    {
        foo = var * bar; // 1
    }
    void g()
    {
        foo = var * bar // 2
    }
    void h(integer);

private:
    integer var = 0, foo = 0, bar = 0;
};

A::integer out_f(A::integer);

void A::h(integer var)
{
    foo = out_f(var); // 3
}
// 当编译器处理语句1时，var会先从函数作用域内找，故语句1中的var是指函数形参
// 若需使用类成员var，则需写成 this->var
// 若需使用全局变量var，则需写成 ::var
// 当编译器处理语句2时，此处的var则是类成员var
/* 
 * 当编译器处理语句3时，虽然out_f在类定义之前不可见，但根据在外部作用域的成员函数
 * 前面找的规则，h函数可以发现out_f的声明。若把out_f的声明移到h函数的定义的下方
 * 则会报错
 */
```
