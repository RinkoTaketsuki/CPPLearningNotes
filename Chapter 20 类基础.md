# Chapter 20 类基础

## 1. this指针

指向当前对象，是顶层const指针（class_t *const this = &current_object）  
成员函数必须通过this指针访问类内其他成员  
成员函数直接使用其他成员时其实是省略了this  
this也可看做是每一个成员函数的隐式参数  
成员函数返回this指针指向的对象时，返回类型必须是引用类型（左值）

## 2. 常量成员函数

用法：在函数声明的括号后面加一个const标识符  
由于this指针本身不带底层const，故普通成员函数不能访问常量对象  
常量成员函数的this指针是const class_t *const类型，故可以访问常量对象  
也因此，常量成员函数不能修改其他成员

## 3. 类的作用域

类本身是一个作用域，成员函数内部是嵌套的作用域  
类内部定义的函数是隐式的inline函数
编译器先编译成员声明，再编译成员函数体，故成员函数可以写在其他成员的前面  
可以定义非成员函数来实现类的某些接口，但一般把这些函数声明在和相关类的同一个头文件内

## 4. 构造函数

1. 构造函数不能声明为const，创建const对象时，先调用构造函数初始化，然后才被赋予const属性，故构造函数可以向const对象写值  
2. 编译器创建的默认构造函数（合成的默认构造函数）的规则是：
    - 若存在类内初始值，使用该初始值初始化成员（有些编译器不支持类内初始值）
    - 否则不初始化成员
3. 若在类内定义了非默认构造函数，则编译器不会再创建合成的默认构造函数，此时对象无法默认初始化
4. 合成的默认构造函数可能会初始化为未定义值
5. 若类内有无默认构造函数的类型的成员，则也无法生成合成的默认构造函数
6. 如果在3的情况下还是需要合成的默认构造函数，则可以使用 = default 来声明或定义
7. 构造函数也会根据是否在类内定义决定其是否是inline函数
8. 若编译器支持类内初始值，则无须修改该值时最好不要在构造函数中初始化该值
9. 构造函数初始值列表的使用举例

    ```C++
    class A
    {
    public:
        A();
        A(double, const char*);

    private:
        int m_a;
        double m_b;
        const char* m_c;
    };

    A::A() = default;

    A::A(double b, const char* c): m_a(0), m_b(b), m_c(c)
    {
        cout << "Constructor with initialize list has been called" << endl;
    };

    int main()
    {
        A a(3.14, "hello");
        return 0;
    }
    ```

## 5. 合成的默认拷贝操作

相当于对每个成员分别作赋值操作

## 6. 默认访问权限

class：private  
struct：public

## 7. 友元

在类内部定义或声明函数或类时加friend关键字，说明其不是成员函数或为其他类，但可以访问私有成员  
友元不是类的成员，故可以声明在任何地方  
友元声明仅声明了权限，未声明函数，故须在外部重新声明才能使用，通常把友元和类的声明放在同一个头文件中  
其他类的私有成员函数不能设为友元

## 8. 在类中使用类型别名

