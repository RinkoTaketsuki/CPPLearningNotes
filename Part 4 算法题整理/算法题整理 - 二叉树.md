# 算法题整理 - 二叉树

> 深度：二叉树的根节点到叶子节点的最长路径所包含的节点个数。  
> 满二叉树：若二叉树的深度为 $h$，则包含 $2^h-1$ 个节点的二叉树为满二叉树。  
> 完全二叉树：若二叉树的深度为 $h$，则完全二叉树满足：  
>
>- 除了第 $h$ 层以外所有层节点数均为最大值
>- 第 $h$ 层有 $1 \sim 2^{h-1}$ 个节点，且所有节点均靠左。
>
> 二叉排序树：空树是二叉排序树，二叉排序树中根节点的左子树中每个节点的值均小于根节点的值，根节点的右子树中每个节点的值均大于根节点的值，且这两棵子树也是二叉排序树。  
> AVL 树：AVL 树是一种特殊的二叉排序树。空树是 AVL 树。若 AVL 树非空，则其左右子树的深度差的绝对值不超过 1，且左右子树也是 AVL 树。  
> 二叉树的顺序存储：若某一节点下标为 $i$，则其左孩子的下标为 $2i+1$，右孩子的下标为 $2i+2$。若二叉树是完全二叉树，则顺序表中间没有空项。  

## 前序遍历（迭代法）

> 图的深度优先遍历相当于二叉树的前序遍历  

先将根节点入栈，之后每次迭代先将栈顶元素出栈到结果数组，再将右孩子入栈，再将左孩子入栈。迭代结束条件为栈空。

## 中序遍历（迭代法）

每次迭代若当前节点不为空，则将当前节点入栈，下次迭代处理左孩子；若当前节点为空，则栈顶为父节点，将栈顶节点出栈到结果数组，下次迭代处理该父节点的右孩子即可。最终若当前节点为空且栈为空，则说明整棵树已经遍历完毕。  

## 后序遍历（迭代法）

将前序遍历的顺序改为 根->右->左，再将结果反转即可。

## 通过将空结点入栈实现前中后序遍历的统一思路

将栈初始化为只有根节点，每次迭代时先弹出栈顶节点作为当前节点，迭代的结束条件为栈空。

- 若当前节点非空，则按照遍历的相反顺序（如中序遍历是右->中->左）入栈，需要注意的是若左右孩子为空则不入栈，当前（中）节点入栈后还要再入栈一个空节点。
- 若当前节点为空，则先弹出一个节点（该节点必为空节点），再弹出一个节点（该节点为当前节点的父节点）到结果数组。

## Morris 遍历

> 利用二叉树中大量的空指针实现常数空间复杂度的遍历  

### 前序遍历

令当前节点为根节点，之后进行如下的迭代，迭代的结束条件为当前节点为空节点：

- 若当前节点的左子树为空，则将当前节点加入结果数组，再令当前节点为右孩子继续迭代。
- 若当前节点的左子树非空，则首先找到左子树的最右侧节点（中序前驱节点，须注意在指针不断右移时可能会使指针移回当前节点，要添加相应的停止条件使指针最后指向真正的前驱节点）。若前驱节点的右子树为空，说明左子树尚未遍历，将当前节点加入结果数组，并将前驱节点的右孩子改为当前节点，最后令当前节点为当前节点的左孩子继续迭代；若前驱节点的右子树非空，则其必指向当前节点，说明左子树已遍历完成，此时将前驱节点的右子树重新设为空，令当前节点为当前节点的右孩子继续迭代。

上面的第一条对应 空->中->右 的遍历顺序，第二条对应 中->左->右 的遍历顺序。须注意特殊情况：当前节点为叶子节点时，其右孩子会指向祖先节点，下一次迭代会回到该祖先节点并将右孩子重新设为空，这样便使得原二叉树不会被更改。  

### 中序遍历

令当前节点为根节点，之后进行如下的迭代，迭代的结束条件为当前节点为空节点：

- 若当前节点的左子树为空，则将当前节点加入结果数组，再令当前节点为右孩子继续迭代。
- 若当前节点的左子树非空，则首先找到左子树的最右侧节点（中序前驱节点，须注意在指针不断右移时可能会使指针移回当前节点，要添加相应的停止条件使指针最后指向真正的前驱节点）。若前驱节点的右子树为空，说明左子树尚未遍历，将前驱节点的右孩子改为当前节点，最后令当前节点为当前节点的左孩子继续迭代；若前驱节点的右子树非空，则其必指向当前节点，说明左子树已遍历完成，此时将当前节点加入结果数组，将前驱节点的右子树重新设为空，令当前节点为当前节点的右孩子继续迭代。

上面的第一条对应 空->中->右 的遍历顺序，第二条对应 左->中->右 的遍历顺序。须注意特殊情况：当前节点为叶子节点时，其右孩子会指向祖先节点，下一次迭代会回到该祖先节点并将右孩子重新设为空，这样便使得原二叉树不会被更改。  

### 后序遍历

令当前节点为根节点，之后进行如下的迭代，迭代的结束条件为当前节点为空节点，迭代结束后要将从根节点到最右边节点这条路径上的节点倒序加入结果数组中：

- 若当前节点的左子树为空，则令当前节点为右孩子继续迭代。
- 若当前节点的左子树非空，则首先找到左子树的最右侧节点（中序前驱节点，须注意在指针不断右移时可能会使指针移回当前节点，要添加相应的停止条件使指针最后指向真正的前驱节点）。若前驱节点的右子树为空，将前驱节点的右孩子改为当前节点，令当前节点为当前节点的左孩子继续迭代；若前驱节点的右子树非空，则其必指向当前节点，将前驱节点的右子树重新设为空，并将左孩子到前驱节点这条路径上的节点倒序加入结果数组中，令当前节点为当前节点的右孩子继续迭代。

若要理解这种遍历方式为何是后序遍历，可以这样重画二叉树的拓扑：从根节点开始，左孩子向正下方画，右孩子向正右方画，高度相同的连成一条线的节点为一层，则右侧无节点的节点会指回上一层的最左侧节点，每次输入到结果数组时从右向左输入一层的节点并将该层最右侧的回指指针删除。须注意特殊情况：当前节点为叶子节点时，其右孩子会指向祖先节点，下一次迭代会回到该祖先节点并将右孩子重新设为空，这样便使得原二叉树不会被更改。  

## 层序遍历

使用图的广度优先遍历算法（队列迭代法）即可，若要每层单独输出一个数组，则要记录队列大小，每次出队元素数量达到这个大小时说明已经遍历完一层，重新记录队列大小开始输出下一个数组。迭代结束条件为队列空。  

## 二叉排序树的实现

> 以下所有代码仅要求 `ElementType` 支持 `operator<(const ElementType&, const ElementType&)` 以及默认、拷贝构造函数、拷贝赋值运算符。

节点数据结构：包括存储的具体数据、父节点指针、左右孩子指针。

```cpp
template <typename ElementType>
struct TreeNode {
 using Pointer = std::shared_ptr<TreeNode<ElementType>>;

 TreeNode(ElementType element = ElementType(), Pointer parent = nullptr) : 
  element(element), parent(parent), leftChild(nullptr), rightChild(nullptr) {}

 ElementType element;
 Pointer parent;
 Pointer leftChild;
 Pointer rightChild;
};
```

二叉排序树数据结构：保存根节点指针即可。  
成员函数：`find`、`insert`、`erase`。  
`find` 查找给定值的所在位置，若查找不到则返回 `nullptr`。  
`insert` 将给定值插入合适的位置，若树中已存在该值则不作更改。  
`erase` 删除给定值对应的节点，若该值不存在则不作更改。  

### erase 的实现细节

定义函数 `__findMin(Position)` 从输入节点开始查找最左侧的节点，即 Position 对应的子树的最小值节点。  
定义函数 `__eraseZeroOrOneChildNonRootNode(Position)` 输入参数必须是叶子节点或只有一个孩子的节点，且不能为根节点，该函数会执行具体的节点删除操作。

首先调用 `this->find` 查找给定值 `element`，若未找到则不作处理，若为根节点则分成如下三种情况：

1. 根节点有两个孩子，此时将根节点删除根节点右子树的最小节点即可。
2. 根节点有一个孩子，此时将根节点设为该孩子，之后将该节点的父节点指针置为空。

### 完整实现代码

```cpp
template <typename ElementType>
class SearchTree {
public:
    using Position = typename TreeNode<ElementType>::Pointer;

    SearchTree() : __root(nullptr) {}

    Position find(const ElementType& element) {
        Position p = __root;
        while (nullptr != p) {
            if (element < p->element) p = p->leftChild;
            else if (p->element < element) p = p->rightChild;
            else break; // p->element == element
        }
        return p;
    }

    Position insert(const ElementType& element) {
        if (nullptr == __root)
            __root = Position(new TreeNode<ElementType>(element));

        Position p = __root;

        while (true) {
            if (element < p->element) {
                if (nullptr == p->leftChild)
                    p->leftChild = Position(new TreeNode<ElementType>(element, p));
                p = p->leftChild;
            }
            else if (p->element < element) {
                if (nullptr == p->rightChild)
                    p->rightChild = Position(new TreeNode<ElementType>(element, p));
                p = p->rightChild;
            }
            else break; // p->element == element
        }
        return p;
    }

    void erase(const ElementType& element) {
        Position x = this->find(element);

        if (nullptr == x) return;
        
        if (__root == x) {
            if (nullptr != __root->leftChild && nullptr != __root->rightChild) {
                Position p = __findMin(__root->rightChild);
                __root->element = p->element;
                __eraseZeroOrOneChildNonRootNode(p);
            }
            else if (nullptr != __root->leftChild) {
                __root = __root->leftChild;
                __root->parent = nullptr;
            }
            else if (nullptr != __root->rightChild) {
                __root = __root->rightChild;
                __root->parent = nullptr;
            }
            else __root = nullptr; // __root is leaf node
        }
        else { // __root != x
            if (nullptr != x->leftChild && nullptr != x->rightChild) {
                Position p = __findMin(x->rightChild);
                x->element = p->element;
                __eraseZeroOrOneChildNonRootNode(p);
            }
            else __eraseZeroOrOneChildNonRootNode(x);
        }
    }

private:
    static Position __findMin(Position start) {
        if (nullptr == start) return nullptr;
            while (nullptr != start->leftChild)
                start = start->leftChild;
        return start;
    }

    static void __eraseZeroOrOneChildNonRootNode(Position node) {
        Position p = node->parent;
        if (node == p->leftChild) {
            if (nullptr != node->leftChild) {
                p->leftChild = node->leftChild;
                p->leftChild->parent = p;
            }
            else if (nullptr != node->rightChild) {
                p->leftChild = node->rightChild;
                p->leftChild->parent = p;
            }
            else p->leftChild = nullptr;
        }
        else { // node == p->rightChild
            if (nullptr != node->leftChild) {
                p->rightChild = node->leftChild;
                p->rightChild->parent = p;
            }
            else if (nullptr != node->rightChild) {
                p->rightChild = node->rightChild;
                p->rightChild->parent = p;
            }
            else p->rightChild = nullptr;
        }
    }

    Position __root;
};
```

## AVL 树的实现

首先实现 AVL 树的节点类。

```cpp
// AVLNode.hpp
#pragma once
#include <memory>
#include <tuple>
#include <string>

// annotations
template <typename Data> class AVLNode;
template <typename Data> using AVLPointer = std::shared_ptr<AVLNode<Data>>;
template <typename Data> int 
getHeight(AVLPointer<Data> node);
template <typename Data> void
updateHeight(AVLPointer<Data> node);
template <typename Data> std::pair<AVLPointer<Data>, int>
updateHeightsBottomUp(AVLPointer<Data> start);

// "Data" must support operator<, default and copy constructor,
// and copy assignment.
template <typename Data>
class AVLNode {
public:
    // in-class type annotations
    using Pointer = AVLPointer<Data>;
 
    // friend function annotations
    friend int getHeight<Data>(AVLPointer<Data> node);
    friend void updateHeight<Data>(AVLPointer<Data> node);
    friend auto updateHeightsBottomUp<Data>(AVLPointer<Data> start) ->
        std::pair<AVLPointer<Data>, int>;

    // constructor
    AVLNode(Pointer parent = nullptr, const Data& value = Data()):
        __height(0), __value(value), __parent(parent),
        __leftChild(nullptr), __rightChild(nullptr) {}

    // get-set methods
    Pointer getParent() const { return __parent; }
    void setParent(Pointer node) { __parent = node; }
    Pointer getLeftChild() const { return __leftChild; }
    void setLeftChild(Pointer node) { __leftChild = node; }
    Pointer getRightChild() const { return __rightChild; }
    void setRightChild(Pointer node) { __rightChild = node; }
    Data getValue() const { return __value; }
    void setValue(const Data& value) { __value = value; }

    /**
    * serialize the AVLNode
    * e.g.
    * this->getValue() == 2
    * this->getParent()->getValue() == 0
    * this->getLeftChild() == nullptr
    * this->getRightChild()->getValue() == 1
    * then return "1 <- 2 ^ 0"
    */
    std::string serialize() const {
        std::string result;
        if (nullptr != __leftChild)
            result += std::to_string(__leftChild->getValue()) + " <- ";
        result += std::to_string(__value);
        if (nullptr != __rightChild)
            result += " -> " + std::to_string(__rightChild->getValue());
        if (nullptr != __parent)
            result += " ^ " + std::to_string(__parent->getValue());
        return result;
    }

private:
    Data __value; int __height;
    Pointer __parent, __leftChild, __rightChild;
};


// Search a value in a tree. If input an empty tree, it will return nullptr.
template <typename Data> AVLPointer<Data>
search(const Data& value, AVLPointer<Data> tree) {
    AVLPointer<Data> current = tree;
    while (nullptr != current) {
        const Data& currentValue = current->getValue();
        if (value < currentValue) current = current->getLeftChild();
        else if (currentValue < value) current = current->getRightChild();
        else return current;
    }
    return nullptr;
}

// Check if the node exists in the tree. If input an empty node, it will return true.
// If input a non-empty node but an empty tree, it will return false. 
template <typename Data> inline bool
exist(AVLPointer<Data> node, AVLPointer<Data> tree) {
    return nullptr == node ?
        true : nullptr != search(node->getValue(), tree);
}

// Get the height of the node. If input an empty node, it will return -1.
// If input an leaf node, it will return 0.
// If input an non-empty and non-leaf node,
// it will return the longest distance between the node and it's farest leaf.
template <typename Data> inline int
getHeight(AVLPointer<Data> node) {
    return nullptr == node ?
        -1 : node->__height;
}

// Update the height of the node by checking the children's height.
// In other words, let the height of the node be
// the greater height of the children's heights plus 1.
// If input an empty node, it will do nothing.
template <typename Data> inline void
updateHeight(AVLPointer<Data> node) {
    if (nullptr != node)
        node->__height = std::max(
            getHeight<Data>(node->__leftChild),
            getHeight<Data>(node->__rightChild)) + 1;
}

// Update the heights bottom-up by the path: start to root node.
// When updating, if we find the unbalanced tree for the first time,
// we will record it and it's balance factor.
// If input an empty start node or we can't find the smallest unbalanced tree,
// it will return { nullptr, 0 }.
// Else, it will return { smallest unbalaced tree, balance factor }.
// Note: A tree's balance factor is
// the height of the left child minus the height of the right child.
template <typename Data> std::pair<AVLPointer<Data>, int>
updateHeightsBottomUp(AVLPointer<Data> start) {
    AVLPointer<Data> smallestUnbalacedTree(nullptr);
    int balanceFactor = 0;
    while (nullptr != start) {
        int lh = getHeight<Data>(start->getLeftChild());
        int rh = getHeight<Data>(start->getRightChild());
        if (nullptr == smallestUnbalacedTree && abs(lh - rh) > 1) {
            smallestUnbalacedTree = start;
            balanceFactor = lh - rh;
        }
        start->__height = std::max(lh, rh) + 1;
        start = start->__parent;
    }
    return { smallestUnbalacedTree, balanceFactor };
}

// Left-rotate the given tree, return the new root node of the new tree.
// After the rotation, every node in the new tree will be with the correct height.
// If input a empty tree, it will return nullptr.
// If input a tree without a right child, it will do nothing and return the old root node.
template <typename Data> AVLPointer<Data>
leftRotate(AVLPointer<Data> root) {
    if (nullptr == root) return nullptr;
    AVLPointer<Data> rc = root->getRightChild();
    if (nullptr == rc) return root;
    root->setRightChild(rc->getLeftChild());
    rc->setLeftChild(root);
    rc->setParent(root->getParent());
    root->setParent(rc);
    if (nullptr != root->getRightChild())
        root->getRightChild()->setParent(root);
    updateHeight<Data>(root);
    updateHeight<Data>(rc);
    return rc;
}

// Right-rotate the given tree, return the new root node of the new tree.
// After the rotation, every node in the new tree will be with the correct height.
// If input a empty tree, it will return nullptr.
// If input a tree without a left child, it will do nothing and return the old root node.
template <typename Data> AVLPointer<Data>
rightRotate(AVLPointer<Data> root) {
    if (nullptr == root) return nullptr;
    AVLPointer<Data> lc = root->getLeftChild();
    if (nullptr == lc) return root;
    root->setLeftChild(lc->getRightChild());
    lc->setRightChild(root);
    lc->setParent(root->getParent());
    root->setParent(lc);
    if (nullptr != root->getLeftChild())
        root->getLeftChild()->setParent(root);
    updateHeight<Data>(root);
    updateHeight<Data>(lc);
    return lc;
}

// Adjust the given unbalanced tree of which the inserted node is in the left child of the left child.
// It will return the new root node of the new tree.
// After the adjustment, every node in the new tree will be with the correct height.
template <typename Data> inline AVLPointer<Data>
adjustLL(AVLPointer<Data> root) {
    return rightRotate<Data>(root);
}

// Adjust the given unbalanced tree of which the inserted node is in the right child of the left child.
// It will return the new root node of the new tree.
// After the adjustment, every node in the new tree will be with the correct height.
template <typename Data> inline AVLPointer<Data>
adjustLR(AVLPointer<Data> root) {
    if (nullptr != root) {
        root->setLeftChild(leftRotate<Data>(root->getLeftChild()));
        // After the rotation on the left child, the real height of the root may be modified.
        updateHeight(root);
        return rightRotate<Data>(root);
    }
    return nullptr;
}

// Adjust the given unbalanced tree of which the inserted node is in the right child of the right child.
// It will return the new root node of the new tree.
// After the adjustment, every node in the new tree will be with the correct height.
template <typename Data> inline AVLPointer<Data>
adjustRR(AVLPointer<Data> root) {
    return leftRotate<Data>(root);
}

// Adjust the given unbalanced tree of which the inserted node is in the left child of the right child.
// It will return the new root node of the new tree.
// After the adjustment, every node in the new tree will be with the correct height.
template <typename Data> inline AVLPointer<Data>
adjustRL(AVLPointer<Data> root) {
    if (nullptr != root) {
        root->setRightChild(rightRotate<Data>(root->getRightChild()));
        // After the rotation on the right child, the real height of the root may be modified.
        updateHeight(root);
        return leftRotate<Data>(root);
    }
    return nullptr;
}

// Try to adjust the given unbalanced tree correctly by 
// the information of the inserted node and the balance factor.
// Note that the given tree would be modified only if abs(balance factor) == 2,
// or it will do nothing.
template <typename Data> AVLPointer<Data>
rotate(
    AVLPointer<Data> unbalancedTree,
    AVLPointer<Data> insertedNode,
    const int balanceFactor) {
    // Check if an empty tree is input.
    if (nullptr == unbalancedTree) return nullptr;

    AVLPointer<Data> lt = unbalancedTree->getLeftChild();
    AVLPointer<Data> rt = unbalancedTree->getRightChild();

    // Check if the given tree satisfy the condition of adjustRX.
    if (-2 == balanceFactor && nullptr != rt) {
        if (exist<Data>(insertedNode, rt->getRightChild()))
            return adjustRR<Data>(unbalancedTree);
        else
            return adjustRL<Data>(unbalancedTree);
    }

    // Check if the given tree satisfy the condition of adjustLX.
    else if (2 == balanceFactor && nullptr != lt) {
        if (exist<Data>(insertedNode, lt->getLeftChild()))
            return adjustLL<Data>(unbalancedTree);
        else
            return adjustLR<Data>(unbalancedTree);
    }

    else return unbalancedTree;
}

// Serialize the given tree in pre-order.
template <typename Data> std::string
serialize(AVLPointer<Data> tree) {
    if (nullptr == tree) return "";
    return tree->serialize() + '\n' + 
        serialize<Data>(tree->getLeftChild()) +
        serialize<Data>(tree->getRightChild());
}
```

基于如上代码，我们实现了 AVL 树的序列化、插入节点的四种调节、节点高度的判断和自下而上更新节点高度并获取最小不平衡子树的方法，这些方法将用于 AVL 树的插入和删除，接下来是 AVL 树的实现。

```cpp
// AVLTree.hpp
#pragma once
#include "AVLNode.hpp"

// annotations
template <typename Data> class AVLTree;

// Check if the given tree is a balanced tree.
// If input an empty tree, it will return true.
template <typename Data> bool
check(AVLPointer<Data> tree) {
    if (nullptr == tree) return true;

    Data val = tree->getValue();
    AVLPointer<Data> lc = tree->getLeftChild();
    AVLPointer<Data> rc = tree->getRightChild();

    // Check if the heights of the root and the two children are valid.
    if (getHeight<Data>(tree) != std::max(getHeight<Data>(lc), getHeight<Data>(rc)) + 1)
        return false;
    if (abs(getHeight<Data>(lc) - getHeight<Data>(rc)) > 1)
        return false;

    // Check if the left child and the right child are both balanced trees,
    // and if the value of the two child is valid.
    bool lcIsValid = true, rcIsValid = true;
    if (nullptr != lc) {
        if (!(lc->getValue() < val)) return false;
        lcIsValid = check<Data>(lc);
    }
    if (nullptr != rc) {
        if (!(val < rc->getValue())) return false;
        rcIsValid = check<Data>(rc);
    }
    return lcIsValid && rcIsValid;
}

// Check if the given tree is a balanced tree.
template <typename Data> bool
check(AVLTree<Data>& tree) {
    return check(tree.__root);
}

template <typename Data>
class AVLTree {
    // friend function annotations
    friend bool check<Data>(AVLTree<Data>& tree);

public:
    // constructor
    AVLTree() : __root(nullptr) {}

    // Insert the given value and adjust the tree.
    // If the value is already exist, then it will do nothing.
    void insert(const Data& value) {
        // Special case that it is an empty tree.
        if (nullptr == __root) {
            __root.reset(new AVLNode<Data>(nullptr, value));
            return;
        }

        // Pointer to search the insert position, which is initialized by the root node.
        AVLPointer<Data> current = __root;

        // Search the insert position, insert the node and adjust the tree.
        while (true) {
            const Data& currentValue = current->getValue();

            // The given value will be in the left child.
            if (value < currentValue) {
                AVLPointer<Data> lc = current->getLeftChild();

                // The given value will be the left child.
                if (nullptr == lc) {
                    // Build the new node and connect the pointer.
                    AVLPointer<Data> newLc(new AVLNode<Data>(current, value));
                    current->setLeftChild(newLc);
                    __adjustAfterInsertion(newLc);
                    break;
                }

                // The left child is existed, so we recursively search the left child.
                else current = lc;
            } // if (value < currentValue)

            // The given value will be in the right child.
            else if (currentValue < value) {
                AVLPointer<Data> rc = current->getRightChild();

                // The given value will be the left child.
                if (nullptr == rc) {
                // Build the new node and connect the pointer.
                    AVLPointer<Data> newRc(new AVLNode<Data>(current, value));
                    current->setRightChild(newRc);
                    __adjustAfterInsertion(newRc);
                    break;
                }

                // The right child is existed, so we recursively search the right child.
                else current = rc;
            } // else if (currentValue < value)

            // The given value is already exist.
            else return;
        } // while (true)
    }

    // Erase the given value and adjust the tree.
    // If the value is not existed, then it will do nothing.
    void erase(const Data& value) {
        // The positon of the node will be erased.
        AVLPointer<Data> pos = search<Data>(value, __root);
        if (nullptr == pos) return;
        AVLPointer<Data> par = pos->getParent();

        // The node will be erased is not the root node.
        if (nullptr != par) {
            // If the node is the left child of its parent. 
            bool isLeft = pos->getParent()->getLeftChild() == pos;

            // The condition that the node only has the right child (maybe empty tree).
            // If the right child is empty, then the node is a leaf node.
            if (nullptr == pos->getLeftChild()) {
                // Reconnect the right child to the parent.
                if (isLeft) {
                    par->setLeftChild(pos->getRightChild());
                    if (nullptr != par->getLeftChild())
                        par->getLeftChild()->setParent(par);
                }
                else {
                    par->setRightChild(pos->getRightChild());
                    if (nullptr != par->getRightChild())
                        par->getRightChild()->setParent(par);
                }
                __adjustAfterErase(par);
            } // if (nullptr == pos->getLeftChild())

            // The condition that the node only has the left child (impossible to be empty tree).
            else if (nullptr == pos->getRightChild()) {
                // Reconnect the left child to the parent.
                if (isLeft) {
                    par->setLeftChild(pos->getLeftChild());
                    if (nullptr != par->getLeftChild())
                        par->getLeftChild()->setParent(par);
                }
                else {
                    par->setRightChild(pos->getLeftChild());
                    if (nullptr != par->getRightChild())
                        par->getRightChild()->setParent(par);
                }
                __adjustAfterErase(par);
            } // else if (nullptr == pos->getRightChild())

            // The condition that the node has the both children (each child is not empty).
            else {
                // The minimum value(node) in the right subtree.
                AVLPointer<Data> minimumRight = pos->getRightChild();
                while (nullptr != minimumRight->getLeftChild())
                    minimumRight = minimumRight->getLeftChild();

                // Move the minimumRight to pos and erase the minimumRight.
                pos->setValue(minimumRight->getValue());
                AVLPointer<Data> mrPar = minimumRight->getParent();
                if (mrPar == pos) mrPar->setRightChild(nullptr);
                else mrPar->setLeftChild(nullptr);
                __adjustAfterErase(mrPar);
            } // else
        } // if (nullptr != par)

        // The node will be erased is the root node.
        else {
            // The conditions that the root only has zero one child.
            if (nullptr == __root->getLeftChild()) {
                __root = __root->getRightChild();
                if (nullptr != __root) __root->setParent(nullptr);
                __adjustAfterErase(__root);
            }
            else if (nullptr == __root->getRightChild()) {
                __root = __root->getLeftChild();
                __root->setParent(nullptr);
                __adjustAfterErase(__root);
            }

            // The condition that the root has the both children (each child is not empty).
            else {
                // The minimum value(node) in the right subtree.
                AVLPointer<Data> minimumRight = __root->getRightChild();
                while (nullptr != minimumRight->getLeftChild())
                    minimumRight = minimumRight->getLeftChild();

                // Move the minimumRight to pos and erase the minimumRight.
                pos->setValue(minimumRight->getValue());
                AVLPointer<Data> mrPar = minimumRight->getParent();
                if (mrPar == __root) mrPar->setRightChild(nullptr);
                else mrPar->setLeftChild(nullptr);
                __adjustAfterErase(mrPar);
            } // else
        } // else
    }

    std::string serialize() {
        return ::serialize(__root);
    }

private:
    void __adjustAfterInsertion(AVLPointer<Data> insertedNode) {
        // condition that the input is invalid
        if (nullptr == insertedNode || nullptr == insertedNode->getParent()) return;

        // After insertion, the real heights of the nodes between (includes)
        // the inserted node's parent and the root node will be modified.
        // So we call the "updateHeightsBottomUp" to make these heights correct.
        // Excepts, we will get the smallest unbalanced tree and
        // the balanced factor caused by the inserted node.
        AVLPointer<Data> smallestUnbalacedTree(nullptr);
        int balancedFactor = 0;
        std::tie(smallestUnbalacedTree, balancedFactor) =
            updateHeightsBottomUp<Data>(insertedNode->getParent());

        // The condition that the inserted node make the tree unbalanced.
        if (nullptr != smallestUnbalacedTree) {
            // Adjust the smallest unbalanced tree.
            // If the tree to be adjusted is not the whole tree,
            // it will reconnect the adjusted tree to the parent of it.
            AVLPointer<Data> parent = smallestUnbalacedTree->getParent();
            AVLPointer<Data> rotatedTree = rotate<Data>(smallestUnbalacedTree, insertedNode, balancedFactor);
            if (nullptr == parent) __root = rotatedTree;
            else if (parent->getLeftChild() == smallestUnbalacedTree) parent->setLeftChild(rotatedTree);
            else parent->setRightChild(rotatedTree);

        // After the adjustment, the real heights of the nodes between (includes)
        // the parent node and the root node will be modified.
        // So we call the "updateHeightsBottomUp" to make these heights correct.
        updateHeightsBottomUp(parent);
    }
 }

    // Another adjustment method of the AVL tree, which is used after the erase operation.
    // In this function, we will adjust the subtree from the start node to the root node recursively.
    // For the current subtree, we will check the heights of the two children, and do the simple rotation to fix the unbalance.
    // Then we will update the height of the parent of the current subtree if current subtree is not the whole tree.
    void __adjustAfterErase(AVLPointer<Data> start) {
        if (nullptr == start) return;

        int lh = getHeight<Data>(start->getLeftChild());
        int rh = getHeight<Data>(start->getRightChild());

        if (__root == start) {
            if (lh - rh > 1) __root = rightRotate<Data>(__root);
            else if (rh - lh > 1) __root = leftRotate<Data>(__root);
            else {
                AVLPointer<Data> parent = start->getParent();
                if (parent->getLeftChild() == start) {
                    if (lh - rh > 1) parent->setLeftChild(rightRotate<Data>(start));
                    else if (rh - lh > 1) parent->setLeftChild(leftRotate<Data>(start));
                }
            }
        }
        else {
            if (lh - rh > 1) parent->setRightChild(rightRotate<Data>(start));
            else if (rh - lh > 1) parent->setRightChild(leftRotate<Data>(start));
            updateHeight(parent);
            __adjustAfterErase(parent);
        }
    }

    AVLPointer<Data> __root;
};
```

## 226. 翻转二叉树

```cpp
// recursion
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (nullptr != root) {
            TreeNode* left = root->left;
            root->left = invertTree(root->right);
            root->right = invertTree(left);
        }
        return root;
    }
};
```

## 589. 一般树的前序遍历

递归法与二叉树递归法类似，迭代法需要注意节点的入栈顺序是从右向左。  

## 590. 一般树的后序遍历

递归法与二叉树递归法类似，迭代法需要注意节点的入栈顺序是从左向右，且最后对遍历结果进行反转。  

## 100. 检查两个二叉树是否相同

```cpp
// recursion
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p && !q)
            return true;
        if (!p || !q || p->val != q->val)
            return false;
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

## 101. 检查二叉树是否轴对称

```cpp
// recursion
class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }
    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```

```cpp
// iteration - queue
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);
        que.push(root->right);
        
        while (!que.empty()) {
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {
                continue;
            }

            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);
            que.push(rightNode->right);
            que.push(leftNode->right);
            que.push(rightNode->left);
        }
        return true;
    }
};
```

```cpp
// iteration - stack
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        stack<TreeNode*> st;
        st.push(root->right);
        st.push(root->left);
        while (!st.empty()) {
            TreeNode* leftNode = st.top(); st.pop();
            TreeNode* rightNode = st.top(); st.pop();
            if (!leftNode && !rightNode) {
                continue;
            }
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            st.push(rightNode->right);
            st.push(leftNode->left);
            st.push(rightNode->left);
            st.push(leftNode->right);
        }
        return true;
    }
};
```

## 572. 检查一棵树是否是另一棵树的子树（考虑空节点）

> 设父树为 s，子树为 t  

1. 先序遍历 s 上的节点，对每个 s 上的节点检查其与 t 是否相等，时间复杂度为 $O(|s||t|)$，空间复杂度为 $O(max\{d_s,d_t\})$，即 s 的深度和 t 的深度的较大者  
2. 获取 s 和 t 的前序遍历序列，需要考虑空节点以保证序列可以唯一表示一棵二叉树，将左空节点记为 lNull，将右空节点记为 rNull。使用 KMP 算法进行串匹配即可，时间复杂度为 $O(|s|+|t|)$，空间复杂度为 $O(|s|+|t|)$  

    ```cpp
    // -10000 <= TreeNode::val <= 10000
    class Solution {
        static constexpr int lNull = INT_MIN;
        static constexpr int rNull = INT_MAX;

        using Array = array<int, 2048ull>;
        Array sArr, tArr;
        int sArrLen = 0, tArrLen = 0;

        static void traverse(TreeNode* root, Array& arr, int& len) {
            if (!root)
                return;
            arr[len++] = root->val;
            if (root->left)
                traverse(root->left, arr, len);
            else
                arr[len++] = lNull;
            if (root->right)
                traverse(root->right, arr, len);
            else
                arr[len++] = rNull;
        }

    public:
        bool isSubtree(TreeNode* s, TreeNode* t) {
            // get the two pre-order arrays
            traverse(s, this->sArr, this->sArrLen);
            traverse(t, this->tArr, this->tArrLen);

            /* --------- KMP Algorithm ---------*/

            vector<int> next(tArrLen, -1);

            // solve the "next" array
            int prefixIdx = -1;
            for (int suffixIdx = 1; suffixIdx < tArrLen; ++suffixIdx) {
                while (prefixIdx >= 0 && tArr[suffixIdx] != tArr[prefixIdx + 1]) {
                    prefixIdx = next[prefixIdx];
                }
                if (tArr[suffixIdx] == tArr[prefixIdx + 1]) {
                    next[suffixIdx] = prefixIdx + 1;
                }
            }

            // match
            int tIdx = -1;
            for (int sIdx = 0; sIdx < sArrLen; ++sIdx) {
                while (tIdx >= 0 && sArr[sIdx] != tArr[tIdx + 1]) {
                    tIdx = next[tIdx];
                }
                if (sArr[sIdx] == tArr[tIdx + 1]) {
                    ++tIdx;
                }
                if (tIdx == tArrLen - 1) {
                    return true;
                }
            }
            return false;
        }
    };
    ```

3. 树哈希法。设计一个二叉树的哈希函数，对 s 中每一个子树计算其哈希值，若某个子树的哈希值与 t 的哈希值相同，则命题成立（假定不考虑哈希碰撞）。一种哈希方法是令 $f(t)=t.val+37p(|t.left|)\cdot f(t.left)+179p(|t.right|)\cdot f(t.right)$，其中函数 $p(n)$ 表示第 $n$ 个质数，37 和 179 可以换成其他质数。时间复杂度近似为 $O(max\{|s|,|t|\})$，空间复杂度近似为 $O(max\{|s|,|t|\})$  

    > 质数表的获取方法 1：埃氏筛法。对 2 到 N 范围内的正整数，设初始质数为 p（p 初始为 2），每次循环排除 p 的所有倍数，即 2p、3p、4p ... kp <= N，排除完之后令 p 为下一个质数，即未排除的数中的 p 的下一个数。循环结束条件为 p 后面没有数。最后剩下的数即为 2 到 N 范围内的所有质数。  
    > 质数表的获取方法 2：欧拉筛法（线性筛）。埃氏筛法的问题在于同一个合数会被检查多次。欧拉筛法与埃氏筛法的区别是会把获取的质数存储在一个列表中。每次循环不再排除所有的倍数，而是排除当前质数表对应的倍数。假定当前质数为 13，则当前循环会排除 2 \* 13、3 \* 13、5 \* 13、7 \* 13、11 \* 13、13 \* 13 这些数。

    ```cpp
    class Solution {
    public:
        static constexpr int MAX_N = 1005;
        static constexpr int MOD = int(1E9) + 7;

        bool vis[MAX_N]{false}; // vis[i]: i has been visited
        int p[MAX_N]{0}; // p[i]: ith prime number, p[0] == 2
        int tot = 0; // length of p

        // Euler Algorithm
        void getPrime() {
            vis[0] = vis[1] = true; tot = 0;
            for (int i = 2; i < MAX_N; ++i) {
                if (!vis[i])
                    p[++tot] = i;
                for (int j = 1; j <= tot && i * p[j] < MAX_N; ++j) {
                    vis[i * p[j]] = true;
                    if (i % p[j] == 0) break;
                }
            }
        }

        // status of a subtree
        struct Status {
            int f; // hash value 
            int s; // node number
            Status(int f_ = 0, int s_ = 0) 
                : f(f_), s(s_) {}
        };

        // hash map whose
        // key: subtree, value: subtree's status
        unordered_map <TreeNode *, Status> hS, hT;
        
        // traverse each node by DFS order and calculate each subtree's status
        // the results will be stored at hS and hT.
        void dfs(TreeNode *o, unordered_map <TreeNode *, Status> &h) {
            h[o] = Status(o->val, 1);
            if (!o->left && !o->right)
                return;
            if (o->left) {
                dfs(o->left, h);
                h[o].s += h[o->left].s;
                h[o].f = (h[o].f + (31LL * h[o->left].f * p[h[o->left].s]) % MOD) % MOD;
            }
            if (o->right) {
                dfs(o->right, h);
                h[o].s += h[o->right].s;
                h[o].f = (h[o].f + (179LL * h[o->right].f * p[h[o->right].s]) % MOD) % MOD;
            }
        }

        bool isSubtree(TreeNode* s, TreeNode* t) {
            getPrime();

            dfs(s, hS);
            dfs(t, hT);

            int tHash = hT[t].f;
            for (const auto &[k, v]: hS) {
                if (v.f == tHash) {
                    return true;
                }
            }
            return false;
        }
    };
    ```

## 104. 求二叉树的最大深度

递归求解即可。或使用层序遍历记录层数。

## 559. 一般树的最大深度

与上题类似。

## 111. 求二叉树的最小深度

递归求解时可以剪枝，若当前处理节点的深度已经大于维护的最小深度则不再处理其子树。若使用层序遍历，则只要检测到叶子节点就直接返回深度，如此即为最小深度。  

```cpp
// recursion
class Solution {
    int result = INT_MAX;
    void traverse(TreeNode* root, int depth) {
        if (depth >= result)
            return;
        if (!root->left && !root->right) {
            result = min(result, depth);
            return;
        }
        if (root->left) {
            traverse(root->left, depth + 1);
        }
        if (root->right) {
            traverse(root->right, depth + 1);
        }
    }
public:
    int minDepth(TreeNode* root) {
        if (!root)
            return 0;
        traverse(root, 1);
        return result;
    }
};
```

## 222. 求完全二叉树的节点个数

1. 直接使用一般二叉树的节点计数方法。

    ```cpp
    class Solution {
    public:
        int countNodes(TreeNode* root) {
            if (nullptr == root) return 0;
            return 1 + countNodes(root->left) + countNodes(root->right);
        }
    };
    ```

2. 在 1 的基础上，每次递归先检查当前子树是否是满二叉树（最左节点和最右节点深度相同），若是满二叉树，则使用公式 $2^h-1$ 计算该子树的节点个数，否则使用传统的递归计算方法。时间复杂度 $O(log^2n)$  

    ```cpp
    class Solution {
    public:
        int countNodes(TreeNode* root) {
            if (root == nullptr) return 0;
            TreeNode* left = root->left;
            TreeNode* right = root->right;
            int leftHeight = 0, rightHeight = 0;
            while (left) {  // 求左子树深度
                left = left->left;
                leftHeight++;
            }
            while (right) { // 求右子树深度
               right = right->right;
                rightHeight++;
            }
            if (leftHeight == rightHeight)
                return (2 << leftHeight) - 1; // 注意(2 << 1) 相当于2 ^ 2，所以 leftHeight 初始为 0
            return countNodes(root->left) + countNodes(root->right) + 1;
        }
    };
    ```

## 110. 检查二叉树是否是平衡二叉树

递归计算每棵子树的高度，顺带检查每棵子树是否平衡即可，注意检测到非平衡树后要剪枝。

## 257. 获得二叉树从根到所有叶子的路径

DFS 回溯记录路径即可。

## 404. 求二叉树所有左叶子之和

递归求和，注意判断左孩子是否是叶子节点即可。

## 513. 求二叉树最深层的最左边的值

1. 维护一个当前到达过的最深深度和对应的最左边的值，使用递归先序遍历，当且仅当（1. 当前深度超过维护的最深深度 2. 当前节点为叶子节点）时才更新最左边的值为当前节点值，直到递归结束。  
2. 使用分层记录结果的层序遍历，返回最后一行的第一个值即可。

## 112. 检查是否有根到叶子的路径中的节点的值的和等于给定值

直接先序遍历，每次将给定值减掉当前节点的值，若找到某叶子节点的值恰好为给定值则条件成立。

## 113. 返回所有路径和等于给定值的根到叶子的路径

1. 仿照 112 题进行先序遍历，不同的是要记录当前路径，且要对给定值和当前路径进行回溯处理。
2. 使用层序遍历，使用哈希表记录每个节点的父节点，队列中记录节点的同时还必须记录当前节点对应的给定值，当前节点为叶子节点时通过哈希表写入结果。

## 105. 从中序和先序遍历序列还原二叉树

递归分块求解

```cpp
struct TreeRange {
    int pb, pe, ib, ie;
};

class Solution {
public:
    TreeNode* build(const vector<int>& preorder, const vector<int>& inorder, const TreeRange tr) {
        const int rootVal = preorder[tr.pb];
        TreeNode* root = new TreeNode(rootVal);

        // current tree has just one leaf node
        if (1 == tr.pe - tr.pb)
            return root;

        // root's index at inorder
        int im = tr.ib;
        for (; im < tr.ie; ++im) {
            if (rootVal == inorder[im]) break;
        }

        TreeRange lr, rr;
        int lsz = im - tr.ib, rsz = tr.ie - im - 1;

        // build left subtree
        if (0 != lsz) {
            lr.ib = tr.ib;
            lr.ie = im;
            lr.pb = tr.pb + 1;
            lr.pe = lr.pb + lsz;
            root->left = build(preorder, inorder, lr);
        }

        // build right subtree
        if (0 != rsz) {
            rr.ib = im + 1;
            rr.ie = tr.ie;
            rr.pb = tr.pb + 1 + lsz;
            rr.pe = tr.pe;
            root->right = build(preorder, inorder, rr);
        }

        return root;
    }

    TreeNode* buildTree(const vector<int>& preorder, const vector<int>& inorder) {
        int n = inorder.size();
        return build(preorder, inorder, { 0, n, 0, n });
    }
};
```

## 106. 从中序和后序遍历序列还原二叉树

递归分块求解

```cpp
class Solution {
private:
    // 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)
    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {
        if (postorderBegin == postorderEnd) return NULL;

        int rootValue = postorder[postorderEnd - 1];
        TreeNode* root = new TreeNode(rootValue);

        if (postorderEnd - postorderBegin == 1) return root;

        int delimiterIndex;
        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }
        // 切割中序数组
        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了

        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);

        return root;
    }

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        // 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};    
```

## 654. 构造“最大二叉树”

> 给定一个不重复的整数数组 nums。“最大二叉树”可以用下面的算法从 nums 递归地构建:
>
> 1. 创建一个根节点，其值为 nums 中的最大值。
> 2. 递归地在最大值 左边 的 子数组前缀上 构建左子树。
> 3. 递归地在最大值 右边 的 子数组后缀上 构建右子树。

直接模拟递归定义即可。

## 700. 搜索二叉搜索树

见基础知识部分。

## 98. 验证二叉树是否是二叉搜索树

1. 根据二叉搜索树的定义递归判断。
2. 检查中序遍历序列是否是严格升序。可以不构造中序遍历序列，只需按照中序顺序遍历二叉树并比较当前节点和前序节点之间的大小关系即可。

## 530. 求二叉搜索树的最小绝对差

中序遍历二叉树并求当前节点和前序节点之间的绝对差即可。

## 501. 求允许相同值的二叉搜索树的众数

中序遍历二叉树并根据当前节点和前序节点之间的的关系确定众数即可。

## 236. 求二叉树中的 p、q 两节点的最近公共祖先

将函数意义改为如下含义：

1. 若树中存在 p 和 q，则返回最近公共祖先。
2. 若只存在 p 和 q 的其中一个，则返回 root。
3. 若不包含 p 或 q，则返回 NULL。

若根节点 root 为 p、q 或空，则显然结果是 root。否则，递归处理左子树和右子树，得到对应的返回值 left 和 right。若 left 和 right 均非空，则说明 p 和 q 分别在两个子树中，返回 root。若二者均为空，则说明 root 对应的子树既不包含 p 也不包含 q。若其中一个为空另一个为非空，则 p 或 q 在非空的那一侧，返回非空的那一侧。如此，若遇到返回非空 root 的场合，则可以说明 root 的兄弟节点必不含 p 或 q，root 的父节点对应的递归必定返回 root，其祖父节点同理。  

由于题目给出的用例一定是同时包含 p 和 q 的树，所以该含义能返回正确结果。

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == q || root == p || root == NULL) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL) return root;
        if (left == NULL) return right;
        return left;
    }
};
```

## 235. 求二叉搜索树中 p、q 两节点的最近公共祖先

若当前节点值恰好介于 p、q 之间，则返回该节点，否则看情况将当前节点设为左孩子或右孩子，进行下一步递归或迭代。

## 701. 向二叉搜索树中的插入节点

见基础知识部分。

## 450. 删除二叉搜索树中的节点

1. 见基础知识部分。
2. 要删除节点有两个非空子树时，也可以把要删除节点的左子树接到右子树的最小节点的左边，这样要删除的节点就变成了只有一个非空子树的节点。

## 669. 删除二叉树中所有值在 [L, R) 区间外的节点

若根节点值在区间左边，则删除根节点和左子树，返回递归修剪过的右子树。若根节点值在区间右边，则删除根节点和右子树，返回递归修剪过的左子树。  
若根节点值在区间内部，则递归修剪两个子树。

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr) return nullptr;
        if (root->val < low) return trimBST(root->right, low, high);
        if (root->val > high) return trimBST(root->left, low, high);
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

## 108. 将有序数组转换为二叉搜索树

二分递归构造即可。

## 538.把二叉搜索树转换为累加树

反向中序遍历并同时更新节点值即可。
