# 算法题整理 - 栈与队列

## 232. 用栈实现队列

使用两个栈 in 和 out，in 用作入队，out 用作出队。入队时直接入栈 in，获取队首时先检查 out 是否为空，若不为空则返回 out 栈顶元素，否则将 in 中的元素逐个出栈在压入 out 中，之后再获取 out 的栈顶元素。出队时使用上一个函数返回队首元素，并将 out 的栈顶元素出栈即可。  

## 225. 用队列实现栈

使用一个队列 q。入栈时先记录 q 的入栈前长度 n，将入栈元素入队，再逐个将队首元素移到队尾，重复 n 次，这样队首元素便是最近插入的元素。出栈时直接将队首元素出队即可。  

## 20. 括号匹配

使用栈暂存字符。遍历字符串，若栈非空且当前字符与栈顶字符匹配，则将栈顶字符出栈，否则将当前字符入栈。  

## 1047. 字符串消消乐，返回消除之后的字符串

与上一题类似，但使用字符串代替栈，把字符匹配改成字符相等，最后返回这个字符串即可。  

## 150. 逆波兰表达式求值

题目中涉及的运算符只有加减乘除，均为二元运算符，故逆波兰表达式的操作数数量一定比运算符数量多 1，由此可得逆波兰表达式的长度一定为奇数，设该长度为 $n$，则有操作数数量为 $\frac{(n+1)}{2}$，运算符数量为 $\frac{(n-1)}{2}$。  
求解逆波兰表达式的值可以使用栈来解决：遍历逆波兰表达式，若当前项为操作数则入栈；否则当前项为运算符，此时需进行两次出栈操作，第一个出栈的为右侧的操作数，第二个出栈的为左侧的操作数，进行相应运算后把运算结果入栈。在该求解过程中，可见操作数会使栈长度加 1，运算符会使栈长度减 1。  
最坏情况下，逆波兰表达式的所有操作数均在运算符的左面，此时栈长度最大可达 $\frac{(n+1)}{2}$。因此，求解时可预先分配栈的存储空间，以节省动态数组的空间再分配所需的开销。  

## 239. 求数组的每个定长窗口中的最大值  

- 单调队列法。设计一个单调队列，入队和出队时需要维护队列的单调不增性。入队时，若队尾元素大于要入队的元素，则不断弹出队尾元素直到队尾元素小于等于要入队的元素；出队时直接出队即可。首先，使用第一个窗口初始化单调队列，即将第一个窗口中的元素从左到右逐个入队。记录队首元素的值为当前窗口的最大值。之后令窗口不断右移，每右移一次进行如下操作：

    1. 将新加入窗口的元素入队。
    2. 查看退出窗口的元素是否为队首元素，若是则出队。
    3. 查看当前队首元素，记录当前窗口的最大值。

    可以证明：每一次循环的末尾时，单调队列中的元素均为当前窗口的元素，且队首元素为当前窗口的最大值。该方法的时间复杂度为 $O(n)$，空间复杂度为 $O(k)$，其中 n 为数组长度，k 为窗口长度。

- 分块法。将原数组 k 个一组分块，最后一块长度可能小于 k。对数组的任意下标 i，求从块首到 i（包含两端）中的元素的最大值 prefixMax[i]；求从 i 到块尾（包含两端）中的元素的最大值 suffixMax[i]。这两个数组的求解可以使用动态规划的方法：  

    $$
    prefixMax[i]= \begin{cases}
    nums[i], & k \mid i \\
    max(nums[i],prefixMax[i-1]), & k\nmid i
    \end{cases}
    $$

    $$
    suffixMax[i]=\begin{cases}
    nums[i], &k \mid (i+1) \\
    max(nums[i],suffixMax[i+1]), & k\nmid i
    \end{cases}
    $$

    须注意特殊情况：$suffixMax[n-1]=nums[n-1]$  

    此时我们可以求每个以 i 开始的窗口的最大值为 $max(prefixMax[i+k-1],suffixMax[i])$。  

## 347. 求数组的前 k 个高频元素

- 首先使用哈希表存储每个元素的出现次数，将哈希表转换成 key-value 二元组的数组，之后使用小顶堆进行求解，小顶堆的排序依据是出现次数。先将二元组数组中的 k 个元素入堆，之后的元素若比堆顶更大，则弹出堆顶并插入当前元素，否则丢弃当前元素。最终堆内元素为前 k 个高频元素。时间复杂度 $O(nlogk)$
- 利用快速排序的分组算法进行求解。平均时间复杂度 $O(n)$，最坏时间复杂度 $O(n^2)$  
    1. 设排序数组为 $arr$；结果数组为 $res$，初始为空数组；排序区间为 $[b,e)$，初始为 $[0,arr.length)$；下面的步骤为循环，设每次迭代的预期插入个数为 $m$，初始为 $k$。
    2. 随机选取排序区间 $[b,e)$ 内的一个元素为 $p$，对排序区间进行分组，使得 $p$ 左边的元素全部小于等于 $p$，右边的元素全部大于 $p$。设当前 $p$ 所在下标为 $i$，则左边区间为 $[b,i)$，长度为 $i-b$，右边区间为 $[i+1,e)$，长度为 $e-i-1$。
    3. 若 $i-b < k$，则说明前 $m$ 个元素均在左边区间内，令 $e:=i$，跳转到 2。若 $k=i-b$ 或 $k=i-b+1$，则前 $m$ 个元素已经确定，将这些元素放入 $res$ 后结束算法。若 $k<i-b+1$，则前 $m$ 个元素必然包含整个左边区间的元素和 $p$，将这些确认已包含的元素放入 $res$，令 $b:=i+1,m:=m-(i-b+1)$，跳转到 2。
