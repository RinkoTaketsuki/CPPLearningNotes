# Chapter 21 构造函数

## 1. 注意事项

1. 构造函数不能声明为 __const__ ，创建 __const__ 对象时，先调用构造函数初始化，然后才被赋予 __const__ 属性，故构造函数可以向 __const__ 对象写值（但必须在初始值列表中）  
2. 编译器创建的默认构造函数（合成的默认构造函数）的规则是：
    - 若存在类内初始值，使用该初始值初始化成员（有些编译器不支持类内初始值）
    - 否则不初始化成员
3. 若在类内定义了非默认构造函数，则编译器不会再创建合成的默认构造函数，此时对象无法默认初始化
4. 合成的默认构造函数可能会初始化为未定义值
5. 若类内有无默认构造函数的类型的成员，则也无法生成合成的默认构造函数
6. 如果在3的情况下还是需要合成的默认构造函数，则可以使用 = default 来声明或定义
7. 构造函数也会根据是否在类内定义决定其是否是inline函数
8. 若编译器支持类内初始值，则无须修改该值时最好不要在构造函数中初始化该值
9. 构造函数初始值列表的使用举例

    ```C++
    class A
    {
    public:
        A();
        A(double, const char*);

    private:
        int m_a;
        double m_b;
        const char* m_c;
    };

    A::A() = default;

    A::A(double b, const char* c): m_a(0), m_b(b), m_c(c)
    {
        cout << "Constructor with initialize list has been called" << endl;
    };

    int main()
    {
        A a(3.14, "hello");
        return 0;
    }
    ```

10. 初始化优先级：类内（就地）初始化 > 构造函数初始化列表

## 2. 初始值列表

### 初始值列表的必要性

构造函数的初始化顺序是先用初始化列表初始化成员变量，再执行函数体中的语句  
若不写初始化列表改为在函数体中赋值，则其实际上执行的是赋值操作而不是初始化操作  
因此若用构造函数初始化 __const__ 类型或引用类型时必须使用初始化列表  
此外，由于在函数体内“初始化”多了一个赋值步骤，其性能也比初始化列表低

### 初始化顺序问题

使用初始化列表时，成员的的初始化顺序为其在类内出现的顺序，与初始化列表中的顺序无关  
但最好保持二者顺序相同，否则有些编译器会有警告

## 3. 默认实参

构造函数可以使用默认实参，当所有参数都有默认实参时，其便是默认构造函数

## 4. 委托构造函数

执行顺序：

- 委托构造函数的初始值列表
- 委托构造函数的函数体
- 本体构造函数

委托构造函数不能和初始化列表混用

## 5. 必须使用默认构造函数的场合

### 对象被默认初始化

1. 在块作用域内不使用任何初始值初始化一个非静态对象或数组时
2. 在当前类含有类类型的成员且当前类使用合成的默认构造函数时

### 对象被值初始化

1. 数组初始化过程中提供的初始值数量小于数组的大小时
2. 不使用初始值定义局部静态变量时
3. 声明当前类的 __vector__ 对象，且 __vector__ 使用只说明元素个数的初始化时，需要调用当前类的默认构造函数

### 其他

设类B有一个类A的成员变量mA，若创建B类型的对象时，其构造函数未用初始值列表对mA初始化，则mA会调用A的默认构造函数进行初始化

## 6. 转换构造函数

构造函数只有一个实参时便是转换构造函数，提供了一种转化到类类型的转换机制  
只能执行一步的，直接的转换，不能包含隐式转换，例子如下：

```C++
class A:
{
public:
    A(const string &str): mem(str) {}
    void memFun(const A&);
    string mem;
};

int main()
{
    b.memFun("hello") // 错误，包含了两步转换
    b.memFun(string("hello")) // 正确，隐式创建了A对象
    b.memFun(A("hello")) // 正确，显式创建了A对象
    return 0;
}
```

可在只有一个实参的构造函数前面添加 __explicit__ 关键字表示其不能作为转换构造函数，但可以用来强转  
__explicit__ 修饰的构造函数只能用于直接初始化

```C++
class A
{
public:
    A() = default;
    explicit A(int n): mem(n) {}
    void memFun(const A&);
    int mem = 0;
};

int var = 0;
A a = var; // 错误，提示不存在从int转换到A的适当构造函数
A a(var); // 正确
a.memFun(var) // 错误
a.memFun(A(var)) // 正确
a.memFun(static_cast<A>(var)) // 正确
```

vector的容量初始化函数是 __explicit__ 的
