# Chapter 4 复合类型：引用和指针

> 基本结构：基本数据类型 + 声明符  
> 面对一条复杂的声明语句时，从右向左阅读更容易理解其含义

## 1. 引用（左值引用） &

1. 引用在定义时必须初始化，因为其为已经存在的对象的别名
2. 引用定义时不可用右值初始化
3. 不可定义引用的引用
4. 引用定义时不能使用类型转换

## 2. 指针 *

1. 空指针 `nullptr`
2. `void*` 指针，只存地址不存类型，无法访问其指向的对象

## 3. 一次定义多个变量

`*` 号和 `&` 号要写在变量名前面

```C++
int *p, i, &r = i;
```

## 4. 对指针的引用

```C++
int *p = nullptr;
int *&r = p;
```

## 5. 右值引用 &&

只能绑定右值，不能绑定左值  
右值引用变量本身是左值，右值引用变量不能绑定右值引用变量  

## 6. std::move()

将括号里的输入参数转化为右值并返回  
如此，括号里的左值会被当做右值返回并在被使用后紧接着被销毁  
调用 `move` 时通常写成 `std::move()` 以避免名字冲突  
移动后原对象必须处于有效的、可析构的状态  

```C++
class A
{
public:
    A(): mem1(new int[10]), mem2(new int(10)) {};
    ~A(): {delete mem2;}
    int *mem1;
    int *mem2;
}

void foo(A &&rra)
{
    std::cout << rra.mem2 << std::endl;
    // 执行完此句后，rra 已被使用，但是原本 rra.mem1 的资源无法销毁
}

int main()
{
    A a;
    A&& rra = std::move(a);
    foo(rra);
    return 0;
}
```
