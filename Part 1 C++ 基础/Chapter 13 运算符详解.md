# Chapter 13 运算符详解

## 1. 算术运算符

> 正负号，四则运算符，取余运算符

1. 算术运算符的运算对象可以为任意的算术类型，返回结果是右值
2. 较小的整数类型参与运算会被提升为较大的类型（一般是int）
3. 正号，加减法运算符可用于指针
4. 由于存在类型提升，bool类型不要参与算术运算，`-true == true`
5. 整数相除结果还是整数（向0取整）
6. 取余运算符的运算对象必须是整数，结果不为0时，符号与左边的数相同

## 2. 关系运算符

> 相等、不等、大小比较

关系运算符的运算对象可以是算术类型和指针类型右值，返回布尔类型右值
不要直接连用！

```C++
int i = 1, j = 2, k = 0;
if (i < j < k) 
{
    // if语句中的表达式会从左到右结合，即先算i < j得到true，再算
    // true < k，此时true会被转化为1
    cout << "OK" << endl;
}
```

## 3. 逻辑运算符

> 与、或、非

逻辑运算符的运算对象可以是能转化为布尔类型的右值，返回布尔类型右值  
注意短路求值！

## 4. 赋值运算符

1. 注意区分初始化和赋值
2. 赋值运算符左边必须是左值
3. 赋值运算符右边可以是初始值列表（注意不是初始化），但初始值列表中的元素个数不能超过左边值能容纳的个数，且列表中元素的所占空间大小不允许超过左边值的所占空间大小（窄化转换）。

    ```C++
    int i = 0; i = {1.0}; // 错误，窄化转换
    ```

4. 注意赋值运算符满足右结合律
5. 可以用赋值运算符和算术运算符代替复合赋值运算符，区别在于前者会多进行一次运算，一般不会对程序逻辑造成影响

## 5. 递增和递减运算符

1. 分为前置版本和后置版本，前置版本返回运算后的结果，后置版本返回运算前的结果  
2. 运算对象必须为左值，前置版本返回运算对象本身（左值），后置版本返回一个右值  
3. 除非必须，否则尽量不用后置版本（有额外的性能消耗）
4. 后置版本常常与解引用运算符联用

    ```C++
    // 遍历vector
    vector<int> v = {1, 2, 3};
    auto b = v.begin();
    while (b != v.end())
        cout << *b++ << endl; // *b++先解引用b再使b自增1
    ```

5. 由于其会改变运算对象本身的值，须格外注意运算顺序

    ```C++
    // 把string变成大写字母
    string s = "hello";
    auto b = s.begin();
    while (b != v.end())
        *b = toupper(*b++) 
    // 错误，由于不知道先算赋值运算符的左边还是右边，结果不可预知
    ```

## 6. 成员访问运算符

1. 须注意其优先级比解引用运算符低
2. 为方便书写引入 -> 符号，`p->m`相当于`(*p).m`
3. 箭头运算符的运算对象是指针，故其返回左值；点运算符的运算对象左值右值均可，故返回的可能是左值也可能是右值

    ```C++
    class A
    {
    public:
        int n;
        A(int num)
        {
            n = num;
        }
        
    }

    int main()
    {
        int m = A(8).n; // A(8).n返回的是右值
        return 0;
    }
    ```

## 7. 条件运算符

> `cond ? expr1 : expr2;`

1. 运算顺序见Chapter12
2. expr1和expr2可以是左值也可以是右值，若二者均为左值，则返回左值，否则返回右值
3. 条件运算符可以嵌套，满足右结合律

    ```C++
    int grade = 100;
    string finalgrade = (grade > 90) ? "high pass" 
                        : (grade < 60) ? "fail" : "pass";
    ```

4. 条件运算符优先级非常低，与输入输出符号联用时注意加括号

## 8. 位运算符

> ~ << >> & | ^（异或）  

1. 运算对象为整数类型或bitset类型，返回右值
2. 小整数类型自动提升
3. 带符号类型的符号位如何处理无明确规定，尽量少用
4. 左移右移均是在空位补0，满足左结合律

## 9. sizeof运算符

1. 运算对象为任意表达式或类型名，返回一个size_t右值，属于常量表达式，括号可以不加  
2. 类似sizeof(*p)的表达式中，p可以为空指针或未初始化指针（但不能是void指针），因为sizeof运算符不会对运算对象进行计算  
3. sizeof的运算对象还可以是用作用域运算符表示的类成员
4. sizeof的运算对象是引用类型时，得到的是被引用对象的所占空间大小
5. sizeof的运算对象为vector或string对象时，只返回固定部分的大小，不计算其中的元素的所占空间

## 10. 逗号运算符

1. 按照从左向右的顺序求值，返回右边的值
2. 常用于for循环括号中的第三个参数

    ```C++
    // 打印矩阵a的副对角线上的值
    int a[100][100] = {0};
    for (size_t i = 0, j = 99; i < 100 && j >= 0; ++i, --j)
        cout << a[i][j] << ' ';
    ```
