# Chapter 16 异常处理

## 1. try 语句

```C++
try
{
    /* program-statements */
}
catch(/* exception declaration1 */)
{
    /* handler-statements1 */
}
catch(/* exception declaration2 */)
{
    /* handler-statements2 */
}
catch(/* exception declaration3 */)
{
    /* handler-statements3 */
}
...
```

1. program-statements 部分声明和定义的变量在外部无法访问，在 `catch` 子句内也无法访问
2. 异常处理时从里往外寻找 `catch` 子句，若最终找不到 `catch` 则会调用 `std::terminal()` 函数终止程序运行
3. 栈展开过程中，如果正处于某语句块内，抛出的异常导致程序退出该语句块，则该语句块内的局部对象会被销毁
4. 栈展开过程中，如果处于构造函数内，则已经初始化的对象也会被销毁
5. 栈展开过程中，如果正在初始化数组或容器，则已经初始化的数组或容器中的对象也会被销毁
6. 以上所说的销毁针对类类型指调用析构函数
7. 析构函数必须保证其抛出的异常能被自己处理，否则析构函数在异常发生位置后的释放资源语句无法执行
8. 若析构函数抛出异常导致析构函数无法继续执行，则会直接调用 `std::terminal()`

## 2. 异常对象

编译器使用异常抛出表达式对异常对象进行拷贝初始化，因此：  

- 该表达式必须是完全类型
- 该表达式如果是类类型，则必须有可访问的析构函数和可访问的拷贝或移动构造函数
- 该表达式如果是数组或函数类型，则自动转换为对应的指针类型
- 该表达式不能是指向局部对象的指针，因为指向的对象可能被销毁

异常对象在异常被处理完毕时被销毁  
`throw` 的异常对象的类型与静态类型一致，如果 `throw` 一个基类指针的解引用，则如果对象是派生类对象，其派生部分将被切除  

## 3. catch 子句

声明部分类似函数形参，类型必须是完全类型，可以是左值引用，不能是右值引用，如果不使用形参可以不写形参名  
使用捕获的异常对象初始化形参，如果形参不是引用则拷贝初始化  
如果形参是基类非引用，则用派生类初始化时派生部分被切除，如果是基类引用则派生部分不被切除，但不能访问派生类特有成员  
通常把更专门的 `catch` 子句放在顶端，派生类异常的处理代码应出现在基类异常的处理代码之前  
`catch` 子句不允许大多数类型转换，除了以下几种：  

- 非常量 -> 常量
- 派生类 -> 基类
- 数组或函数 -> 对应指针

### 空 throw

将异常重新抛出给上一级的 `catch` 子句，只能出现在 `catch` 代码块中，若出现在别的地方则直接调用 `terminate`  
只有当前的 `catch` 子句以引用方式接受异常对象时，对异常对象的更改才能被应用到重新抛出中  

### 捕获所有异常

将 `catch` 子句的参数设为 `...` 即可，必须是最后一个 `catch` 子句，否则在其下方的 `catch` 子句不会执行  

## 4. 函数 try 语句块

## 8. 异常类

> 在此只讨论 `stdexcept` 头文件中定义的异常类

1. 只能默认初始化 `exception` 类，其他必须用 `string` 或 C 字符串初始化
2. `what()` 无参数，返回 `const char*`

类名|说明
:-:|:-:
`exception`|异常类
`runtime_error`|运行时错误类
`range_error`|
`overflow_error`|
`underflow_error`|
`logic_error`|逻辑错误类
`domain_error`|
`invalid_argument`|
`length_error`|
`out_of_range`|
