# Chapter 9 多重继承

## 1. 构造函数

从第一个直接基类开始执行直接基类的构造函数，执行直接基类的构造函数时按原先的规则从最上层的基类开始执行构造函数，之后执行自己的构造函数  
如果使用 `using` 声明继承多个直接基类的构造函数，当这些基类的构造函数有相同形参时，会有二义性冲突，此时只能手动定义  

## 2. 析构函数

调用顺序和构造函数相反，合成的析构函数体为空  

## 3. 拷贝和移动操作

合成版本的拷贝和移动操作会自动执行对基类成员的拷贝和移动操作，自定义这些操作时不能忽略基类成员  
合成版本执行基类的相关操作时和构造函数的执行顺序类似  

## 4. 多态性

默认情况下编译器不会认为哪一个基类“更好”  

```C++
class B1;
class B2;
class D: public B1, public B2 {}

void f(const B1&);
void f(const B2&);
f(D()); // 错误，具有二义性
```

当通过某一个基类的指针或引用访问派生类对象时，只有对应的基类部分可见  

## 5. 名字查找

名字查找时会沿着每一条继承链向上查找，下层的名字会覆盖上层，如果在多个非上下级的基类中找到相同名字则具有二义性，此时必须加作用域前缀  
以上情况如果是相同名字不同形参的函数也会有二义性，如果是不同的访问权限的成员也会有二义性  
先查找名字，后类型检查  

```C++
class B1
{
    void foo(int);
};

class B2
{
public:
    void foo(bool);
};

class D: public B1, B2
{
public:
    void bar()
    {
        foo(1); // 错误，具有二义性
    }
};
```

## 6. 虚继承

默认情况下，如果某个间接基类被继承多次，则会在派生类中保存多个基类成员  
如果声明为虚基类，则该间接基类可被多个直接基类共享，派生类中只保存一个虚基类成员  
在派生列表中添加 `virtual` 关键字可指定直接基类为虚基类  
虚继承的名字查找举例如下：假设虚基类为 B，B 有成员 x，D1，D2 继承 B，D 继承 D1 和 D2  

- 若 D1 和 D2 均未定义 x，则 D 使用 `B::x`
- 若 D1 定义 x 而 D2 未定义，则 D 使用 `D1::x`
- 若 D1 和 D2 都定义 x，则具有二义性

前两种情况如果不是虚继承仍然具有二义性  
虚基类的拷贝控制成员的执行顺序举例如下：  

```C++
struct Character {}
struct BookCharacter: Character {};
struct ZooAnimal {}
struct Bear: virtual ZooAnimal {};
struct ToyAnimal {}
struct TeddyBear: BookCharacter, Bear, virtual ToyAnimal
{
    /* 构造函数执行顺序：先执行虚基类的构造函数，再执行别的构造函数
     * ZooAnimal() （需要显式调用）
     * ToyAnimal() （需要显式调用）
     * Character()
     * BookCharacter()
     * Bear()
     * TeddyBear()
     */
    
    /* 拷贝和移动操作的执行顺序与上面相同 */

    /* 析构函数执行顺序与上面相反 */
};
```
