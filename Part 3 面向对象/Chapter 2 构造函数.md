# Chapter 2 构造函数

## 1. 注意事项

1. 构造函数不能声明为 `const`，创建 `const` 对象时，先调用构造函数初始化，然后才被赋予 `const` 属性，故构造函数可以向 `const` 对象写值（但必须在初始值列表中写值）  
2. 构造函数也会根据是否在类内定义决定其是否是 `inline` 函数
3. 若编译器支持类内初始值，则无须修改该值时最好不要在构造函数中初始化该值
4. 初始化优先级：类内（就地）初始化 > 构造函数初始化列表

### 合成默认构造函数

如果未显式定义任何构造函数，编译器会隐式定义一个默认构造函数（合成的默认构造函数），该构造函数的规则是：  

- 若存在类内初始值，使用该初始值初始化成员（有些编译器不支持类内初始值）
- 否则默认初始化成员

但实际上，如果当前类满足下面三条，则合成默认构造函数会被编译器判定为“没有用的”  

- 没有类类型成员
- 无虚函数
- 不是派生类

此时实际上不会合成默认构造函数，但调用默认构造函数是合法的，只不过相当于没调用  

若类内有无默认构造函数的类型的成员，则合成的默认构造函数是删除的  
若在类内显式定义了非默认构造函数，则编译器不会再合成默认构造函数，但可以使用 `= default` 声明来强制让编译器合成  
任何编译器合成的构造函数、赋值运算符、析构函数都隐式声明为 `inline`  

## 2. 初始值列表

### 初始值列表的必要性

构造函数的初始化顺序是先用初始化列表初始化成员变量，再执行函数体中的语句  
若有成员未在构造函数初始值列表中被初始化，则该成员会被默认初始化  
若不写初始化列表改为在函数体中赋值，则其实际上执行的是赋值操作而不是初始化操作  
因此若用构造函数初始化 `const` 类型或引用类型时必须使用初始化列表  
此外，由于在函数体内“初始化”多了一个赋值步骤，其性能也比初始化列表低  

### 初始化顺序问题

使用初始化列表时，成员的的初始化顺序为其在类内出现的顺序，与初始化列表中的顺序无关，与其是否在初始化列表中出现也无关  
但最好保持二者顺序相同，否则有些编译器会有警告

## 3. 默认实参

构造函数可以使用默认实参，当所有参数都有默认实参时，其便是默认构造函数

## 4. 委托构造函数

执行顺序：

- 委托构造函数的初始值列表
- 委托构造函数的函数体
- 本体构造函数

委托构造函数不能和初始化列表混用

## 5. 必须使用默认构造函数的场合举例

### 对象被默认初始化

1. 在块作用域内不使用任何初始值初始化一个非静态对象或数组时
2. 在当前类含有类类型的成员且当前类使用合成的默认构造函数时

### 对象被值初始化

1. 数组初始化过程中提供的初始值数量小于数组的大小时
2. 不使用初始值定义局部静态变量时
3. 声明当前类的 `vector` 对象，且 `vector` 使用只说明元素个数的初始化时，需要调用当前类的默认构造函数

## 6. 转换构造函数

构造函数只有一个实参时便是转换构造函数，提供了一种转化到类类型的转换机制  
只能执行一步的，直接的转换，不能包含隐式转换，例子如下：

```C++
class A:
{
public:
    A(const string &str): mem(str) {}
    void memFun(const A&);
    string mem;
};

int main()
{
    b.memFun("hello") // 错误，包含了两步转换
    b.memFun(string("hello")) // 正确，隐式创建了A对象
    b.memFun(A("hello")) // 正确，显式创建了A对象
    return 0;
}
```

可在只有一个实参的构造函数前面添加 __explicit__ 关键字表示其不能作为转换构造函数，但可以用来强转  
__explicit__ 修饰的构造函数只能用于直接初始化

```C++
class A
{
public:
    A() = default;
    explicit A(int n): mem(n) {}
    void memFun(const A&);
    int mem = 0;
};

int var = 0;
A a = var; // 错误，提示不存在从int转换到A的适当构造函数
A a(var); // 正确
a.memFun(var) // 错误
a.memFun(A(var)) // 正确
a.memFun(static_cast<A>(var)) // 正确
```

vector的容量初始化函数是 __explicit__ 的

## 7. 拷贝构造函数

使用拷贝初始化时使用（初始化时使用当前类的对象）（转换构造函数的特例）  
只有一个参数，是当前类的常量引用类型（也可以是普通引用）  
拷贝构造函数经常被隐式使用，一般不声明为 `explicit`

### 合成拷贝构造函数

未声明拷贝构造函数或声明为 `default` 时会合成  
通常是把非静态成员变量逐个拷贝，即便是数组成员也会把每个元素逐个拷贝，顶层 `const` 类型的也会被拷贝  
类类型的成员会调用其拷贝构造函数来拷贝  
若定义了移动构造函数和和移动赋值运算符，则合成拷贝构造函数是删除的  
实际上，如果当前类满足下面四条中任意一条，会被编译器判定为无“位逐次拷贝”特性  

- 具有类类型成员，且该成员的类有显式或隐式定义的拷贝构造函数
- 其基类具有显式或隐式定义的拷贝构造函数
- 有虚成员函数  
- 是虚派生类  

此时编译器才会真正地合成拷贝构造函数，否则只会进行简单的位逐次拷贝  

### 其他会触发拷贝构造函数的场合举例

将当前类的对象作为实参传给当前类的非引用形参  
返回非引用的当前类对象  
用花括号初始化当前类的数组或含当前类成员的聚合类  
调用 `vector` 的 `insert` 和 `push` 函数（`emplace` 是直接初始化）

```C++
class A
{
public:
    A() {cout << "Default" << endl;};
    A(const A &obj): {cout << "Copy" << endl;}
};

A f(A obj)
{
    return obj;
}

int main()
{
    A a; // 输出一次 Default
    A b = f(a); // 输出两次 Copy
    return 0;
}
```

### 等号和大括号初始化

按照教材上的说法，这两种属于拷贝初始化，考察如下的情形：

```C++
string str = "hello";
```

教材上认为是先调用了转换构造函数，再调用拷贝构造函数，但编译器跳过了拷贝构造函数  
实际考察g++编译器发现，不管使用哪种符号，只要是用相同类型初始化，便用拷贝构造函数，用不同类型初始化，就用转换构造函数。上面的情形即便未定义拷贝构造函数也可编译通过

## 8. 移动构造函数

只有一个形参，为右值引用类型  

```C++
class A:
{
public:
    // 移动操作不分配任何内存，通常不会抛出异常，故提醒编译器不抛异常
    // 若在类外定义，则声明和定义都要加 noexcept 标识
    A(A &&obj) noexcept: mem(obj.mem)
    {
        // 若不加这句话，则会导致 this->mem 指向无效内存
        // 因为紧接着 obj 会被销毁，其析构函数可能对在 obj.mem 上分配的堆空间进行销毁操作
        // 将 obj.mem 置零，则原来被分配的空间不会被销毁
        obj.mem = nullptr;
    }
    ~A();
private:
    int *mem = 0;
};
```

若不标识 `noexcept`，则如果已经移动了一部分元素，此时抛出异常将导致原来的对象也被改变，如果调用移动构造函数的代码捕获了异常，则会发生不可预料的错误  
比如 `vector` 的 `push_back` 函数，其可能会重新分配堆空间，当把元素搬到新空间时，优先使用标记了 `noexcept` 的移动构造函数，若未标记则会使用拷贝构造函数  

### 合成移动构造函数

只有未定义拷贝构造函数、拷贝赋值运算符和析构函数，且每个非 `static` 成员均支持移动操作时才会自动合成  
若显式声明为 `=default`，且不是所有非 `static` 成员均可移动，则移动操作会被删除  
若有成员定义了拷贝构造函数且未定义移动构造函数，则移动操作会隐式删除  
若有成员未定义拷贝构造函数但无法合成移动构造函数，则移动操作会隐式删除  
若有成员的移动构造函数是删除的或不可访问的，则移动操作会隐式删除  
若类的析构函数是删除的或不可访问的，则移动操作会隐式删除  
